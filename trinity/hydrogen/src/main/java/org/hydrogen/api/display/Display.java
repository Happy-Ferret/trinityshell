/*
 * This file is part of Hydrogen.
 * 
 * Hydrogen is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * Hydrogen is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Hydrogen. If not, see <http://www.gnu.org/licenses/>.
 */
package org.hydrogen.api.display;

import org.hydrogen.api.display.event.DisplayEvent;
import org.hydrogen.api.display.input.Keyboard;
import org.hydrogen.api.display.input.Mouse;
import org.hydrogen.api.error.GetDisplayEventInterruptedException;
import org.hydrogen.api.error.PutDisplayEventInterruptedException;
import org.hydrogen.api.paint.PainterFactory;
import org.hydrogen.display.BaseEventProducingDisplay;

/**
 * A <code>Display</code> provides a basic contract to talk to the underlying
 * native display. One of the most import aspects of the <code>Display</code>
 * interface is the queuing of {@link DisplayEvent}s.
 * <p>
 * <code>DisplayEvent</code>s generated by the underlying native display are
 * fetched and placed on the master queue. The fetching of
 * <code>DisplayEvent</code>s happens when an {@link EventProducer} is added to
 * the <code>Display</code>. This implies that any source can provide events to
 * a <code>Display</code>, including the <code>Display</code> itself. Fetched
 * events can then later be taken from the <code>Display</code>'s master queue
 * for further processing.
 * <p>
 * Other functionality provided by the <code>Display</code> is access to the
 * {@link Mouse} and {@link Keyboard}. {@link Atom}s and
 * {@link PlatformRenderAreaBling}s are also provided by the
 * <code>Display</code>.
 * 
 * @author Erik De Rijcke
 * @since 1.0
 * 
 * @see BaseEventProducingDisplay
 */
public interface Display extends EventProducer {
	/**
	 * Add an <code>EventProducer</code> for this <code>Display</code>.
	 * <p>
	 * Any <code>DisplayEvent</code> produced by the supplied
	 * <code>EventProducer</code> should be queued on this <code>Display</code>
	 * master queue.
	 * 
	 * @param eventProducer
	 *            An {@link EventProducer} for this <code>Display</code>.
	 */
	void addEventProducer(EventProducer eventProducer);

	/**
	 * Flush all pending operations to the underlying native display system.
	 * Useful for <code>Display</code> implementations using a network based
	 * display server protocol.
	 * 
	 * 
	 */
	void flush();

	/**
	 * Retrieve the native identifier for this <code>Display</code>.
	 * <p>
	 * For example, an X11 based display this can return "0.0"
	 * 
	 * @return A <code>String</code> representing the native display.
	 */
	String getDisplayName();

	/**
	 * Retrieve the <code>DisplayPlatform</code> where this <code>Display</code>
	 * originates from.
	 * 
	 * @return The {@link DisplayPlatform} which implements this
	 *         <code>Display</code>.
	 * 
	 */
	DisplayPlatform getDisplayPlatform();

	/**
	 * Indicates if there are any pending <code>DisplayEvent</code>s on the
	 * master queue.
	 * 
	 * @return
	 */
	boolean isMasterQueueEmpty();

	/**
	 * Retrieves ands removes the head <code>DisplayEvent</code> from this
	 * <code>Display</code> master queue.
	 * 
	 * @return The next {@link DisplayEvent}.
	 * 
	 */
	DisplayEvent getEventFromMasterQueue()
			throws GetDisplayEventInterruptedException;

	void addEventToMasterQueue(final DisplayEvent displayEvent)
			throws PutDisplayEventInterruptedException;

	/**
	 * Retrieve the primary <code>Mouse</code> active on this
	 * <code>Display</code>.
	 * 
	 * @return The primary {@link Mouse}.
	 * 
	 */
	Mouse getMouse();

	/**
	 * Retrieve the primary <code>Keyboard</code> active on this
	 * <code>Display</code>.
	 * 
	 * @return The primary {@link Keyboard}
	 */
	Keyboard getKeyBoard();

	/**
	 * Retrieve the <code>PainterFactory</code> responsible for generating
	 * <code>Painter<code>s for this <code>Display</code>. Each of these
	 * <code>Painter</code>s is responsible for the visualization of a
	 * <code>Paintable</code> that lives on this <code>Display</code>.
	 * 
	 * @return A {@link PainterFactory} responsible for all the {@link Painter}
	 *         implementations.
	 * 
	 */
	PainterFactory getPainterFactory();

	/**
	 * Retrieve the root <code>PlatformRenderArea</code>. The root
	 * <code>PlatformRenderArea</code> is the parent of all
	 * <code>PlatformRenderArea</code>s living on this <code>Display</code> and
	 * can not be created.
	 * 
	 * @return The root {@link PlatformRenderArea}.
	 */
	PlatformRenderArea getRootWindow();

	/**
	 * The screen number of the native display used by this <code>Display</code>
	 * for displaying graphical content.
	 * 
	 * @return The default screen number for this <code>Display</code>.
	 */
	int getScreenNr();

	/**
	 * Orderly shut down this <code>Display</code>. All resources living on this
	 * <code>Display</code> will be shut down as well.
	 * <p>
	 * This method does not shut down the underlying native display, it merely
	 * closes the connection to the underlying native display.
	 */
	void shutDown();

	/**
	 * The collection of all {@link Atom}s that are known on this
	 * <code>Display</code>.
	 * 
	 * @return {@link DisplayAtoms}
	 */
	DisplayAtoms getDisplayAtoms();

	/**
	 * The <code>PlatformRenderArea</code> that has the input focus on this
	 * <code>Display</code>
	 * 
	 * @return The focussed {@link PlatformRenderArea}.
	 */
	PlatformRenderArea getInputFocus();
}
