/*
 * This file is part of Fusion-X11.
 * 
 * Fusion-X11 is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * Fusion-X11 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Fusion-X11. If not, see <http://www.gnu.org/licenses/>.
 */
package org.fusion.x11.core;

import org.fusion.x11.core.event.XDestroyNotify;
import org.fusion.x11.core.event.XPropertyNotify;
import org.fusion.x11.core.extension.XExtensions;
import org.fusion.x11.core.input.XKeyboard;
import org.fusion.x11.core.input.XMouse;
import org.fusion.x11.ewmh.Ewmh;
import org.hydrogen.displayinterface.BaseEventProducingDisplay;
import org.hydrogen.displayinterface.PropertyInstance;
import org.hydrogen.displayinterface.event.DestroyNotifyEvent;
import org.hydrogen.displayinterface.event.DisplayEvent;
import org.hydrogen.displayinterface.event.PropertyChangedNotifyEvent;
import org.hydrogen.eventsystem.EventHandler;

// TODO documentation
/**
 * An <code>XDisplay</code> is the fusion-x11 representation of an X display
 * server.
 * <p>
 * <code>DisplayEvent</code>s that arrive on an <code>XDisplay</code> are
 * generated by underlying X11 native display and are automatically fetched. A
 * programmer should therefore not call <code>getNextEvent()</code> unless
 * strictly necessary. Instead automatically fetched <code>DisplayEvent</code>s
 * are placed on a queue and can be retrieved by calling
 * <code>getEventFromQueue()</code>.
 * 
 * @author Erik De Rijcke
 * @since 1.0
 */
public class XDisplay extends BaseEventProducingDisplay {

	private final Long nativePeer;
	private final XCoreInterface xCoreInterface;
	private final XMouse xMouse;
	private final XAtomRegistry xAtomRegistry;
	private final XWindow noneWindow;
	private final XKeyboard xKeyboard;
	private final XExtensions xExtensions;

	private final XCoreAtoms xCoreAtoms;

	private int lastServerTime;
	private final int currentServerTime;

	/**
	 * 
	 * @param displayName
	 * @param screenNr
	 * @param xDisplayPlatform
	 * @param nativePeer
	 * @param xCoreInterface
	 * 
	 */
	public XDisplay(final String displayName, final int screenNr,
			final XDisplayPlatform xDisplayPlatform, final Long nativePeer,
			final XCoreInterface xCoreInterface) {
		super(xDisplayPlatform, displayName, screenNr);
		{
			this.currentServerTime = 0;
			setLastServerTime(getCurrentServerTime());

			this.nativePeer = nativePeer;

			this.xCoreInterface = xCoreInterface;
			this.xAtomRegistry = new XAtomRegistry(this);
			this.xCoreAtoms = new XCoreAtoms(this);
			this.noneWindow = new XWindow(new XID(this,
					XResourceHandle.valueOf(Long.valueOf(0))));
			this.xMouse = xCoreInterface.initXMouse(this);
			this.xKeyboard = xCoreInterface.initXKeyboard(this);
			this.xExtensions = xCoreInterface.initXExtensions(this);
		}
		{
			initBookkeepingHandlers();
			initEventProducers();
		}
		{
			new Ewmh(this);
		}
	}

	/**
	 * 
	 */
	protected void initBookkeepingHandlers() {
		// bookkeeping handlers
		addEventHandler(new EventHandler<XPropertyNotify>() {
			@Override
			public void handleEvent(final XPropertyNotify event) {
				final XWindow window = event.getEventSource();
				final XPropertyXAtom<? extends PropertyInstance> property = event.getChangedProperty();
				window.invalidateProperty(property);
			}
		}, PropertyChangedNotifyEvent.TYPE);
		addEventHandler(new EventHandler<XDestroyNotify>() {
			@Override
			public void handleEvent(final XDestroyNotify event) {
				final XWindow window = event.getEventSource();
				window.getDisplayResourceHandle().getDisplay()
						.getDisplayPlatform().getResourcesRegistry()
						.unregister(window.getDisplayResourceHandle());
			}
		}, DestroyNotifyEvent.TYPE);
	}

	/**
	 * 
	 * @return
	 */
	public XExtensions getxExtensions() {
		return this.xExtensions;
	}

	@Override
	public void flush() {
		this.xCoreInterface.flush(this);
	}

	@Override
	public XDisplayPlatform getDisplayPlatform() {
		return (XDisplayPlatform) super.getDisplayPlatform();
	}

	@Override
	public XMouse getMouse() {
		return this.xMouse;
	}

	/**
	 * The pointer to the native display that is represented by this
	 * <code>XDisplay</code>.
	 * 
	 * @return A native pointer represented by a <code>Long</code>.
	 */
	public Long getNativePeer() {
		return this.nativePeer;
	}

	@Override
	public DisplayEvent getNextEvent() {
		// this method is called by an event fetcher thread. This method should
		// not handle any other functions except fetching events and putting it
		// on the master queue.
		final DisplayEvent returnEvent = this.xCoreInterface.getNextEvent(this);
		return returnEvent;
	}

	@Override
	public DisplayEvent getEventFromMasterQueue() {
		final DisplayEvent returnEvent = super.getEventFromMasterQueue();
		// We fire the display event on this display before returning it.
		// This allows for internal bookkeeping through event listeners to
		// take place before the event is queued on the master event queue
		// of this display.
		fireEvent(returnEvent);
		return returnEvent;
	}

	@Override
	public XWindow getRootWindow() {
		final XWindow returnPlatformRenderArea = this.xCoreInterface
				.getRootWindow(this);
		return returnPlatformRenderArea;
	}

	/**
	 * The <code>XCoreInterface</code> that was used to create this
	 * <code>XDisplay</code>.
	 * 
	 * @return An {@link XCoreInterface}.
	 */
	public XCoreInterface getXCoreInterface() {
		return this.xCoreInterface;
	}

	/**
	 * 
	 * @return
	 */
	public XWindow getNoneWindow() {
		return this.noneWindow;
	}

	@Override
	public void shutDown() {
		super.shutDown();
		this.xCoreInterface.shutDownDisplay(this);
	}

	@Override
	public XKeyboard getKeyBoard() {
		return this.xKeyboard;
	}

	@Override
	public XAtomRegistry getDisplayAtoms() {
		return this.xAtomRegistry;
	}

	@Override
	public XWindow getInputFocus() {
		return this.xCoreInterface.getInputFocus(this);
	}

	/**
	 * 
	 * @return
	 */
	public XCoreAtoms getxCoreAtoms() {
		return this.xCoreAtoms;
	}

	public int getCurrentServerTime() {
		return this.currentServerTime;
	}

	public int getLastServerTime() {
		return this.lastServerTime;
	}

	public void setLastServerTime(final int lastServerTime) {
		this.lastServerTime = lastServerTime;
	}
}
